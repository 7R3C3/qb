{
  "manifest": {
    "name": "zod",
    "version": "3.11.6",
    "description": "TypeScript-first schema declaration and validation library with static type inference",
    "main": "./lib/index.js",
    "types": "./lib/index.d.ts",
    "module": "./lib/index.mjs",
    "exports": {
      ".": {
        "require": "./lib/index.js",
        "import": "./lib/index.mjs"
      },
      "./package.json": "./package.json"
    },
    "files": [
      "/lib"
    ],
    "repository": {
      "type": "git",
      "url": "https://github.com/colinhacks/zod"
    },
    "author": {
      "name": "Colin McDonnell",
      "email": "colin@colinhacks.com"
    },
    "license": "MIT",
    "sideEffects": false,
    "bugs": {
      "url": "https://github.com/colinhacks/zod/issues"
    },
    "homepage": "https://github.com/colinhacks/zod",
    "funding": "https://github.com/sponsors/colinhacks",
    "support": {
      "backing": {
        "npm-funding": true
      }
    },
    "keywords": [
      "typescript",
      "schema",
      "validation",
      "type",
      "inference"
    ],
    "scripts": {
      "check:format": "prettier --check \"src/**/*.ts\" \"deno/lib/**/*.ts\"",
      "fix:format": "prettier --write \"src/**/*.ts\" \"deno/lib/**/*.ts\"",
      "check:lint": "eslint --ext .ts ./src",
      "fix:lint": "eslint --fix --ext .ts ./src",
      "check": "yarn check:lint && yarn check:format",
      "fix": "yarn fix:lint && yarn fix:format",
      "clean": "rm -rf lib/* deno/lib/*",
      "build": "yarn run clean && npm run build:cjs && npm run build:esm && npm run build:deno",
      "build:deno": "node ./deno/build.mjs",
      "build:esm": "rollup --config rollup.config.js",
      "build:cjs": "tsc --p tsconfig.cjs.json",
      "build:types": "tsc --p tsconfig.types.json",
      "rollup": "rollup --config rollup.config.js",
      "test": "node --trace-warnings node_modules/.bin/jest --coverage && yarn run badge",
      "testone": "jest",
      "badge": "make-coverage-badge --output-path ./coverage.svg",
      "prepublishOnly": "npm run test && npm run build && npm run build:deno",
      "play": "nodemon -e ts -w . -x ts-node src/playground.ts --project tsconfig.json --trace-warnings",
      "depcruise": "depcruise -c .dependency-cruiser.js src",
      "benchmark": "ts-node src/benchmarks/index.ts"
    },
    "devDependencies": {
      "@rollup/plugin-typescript": "^8.2.0",
      "@types/benchmark": "^2.1.0",
      "@types/jest": "^26.0.17",
      "@types/node": "^14.14.10",
      "@typescript-eslint/eslint-plugin": "^4.11.1",
      "@typescript-eslint/parser": "^4.11.1",
      "benchmark": "^2.1.4",
      "dependency-cruiser": "^9.19.0",
      "eslint": "^7.15.0",
      "eslint-config-prettier": "^7.1.0",
      "eslint-plugin-ban": "^1.5.2",
      "eslint-plugin-import": "^2.22.1",
      "eslint-plugin-simple-import-sort": "^7.0.0",
      "eslint-plugin-unused-imports": "^1.1.0",
      "husky": "^4.3.4",
      "jest": "^26.6.3",
      "lint-staged": "^10.5.3",
      "make-coverage-badge": "^1.2.0",
      "nodemon": "^2.0.2",
      "prettier": "^2.2.1",
      "rollup": "^2.42.1",
      "rollup-plugin-uglify": "^6.0.4",
      "ts-jest": "^26.4.4",
      "ts-node": "^9.1.0",
      "tslib": "^2.3.1",
      "typescript": "^4.4.4"
    },
    "husky": {
      "hooks": {
        "pre-commit": "lint-staged && yarn build:deno && git add .",
        "pre-push": "lint-staged && yarn build && yarn test"
      }
    },
    "lint-staged": {
      "*.ts": [
        "yarn fix:lint",
        "yarn fix:format"
      ]
    },
    "dependencies": {},
    "_registry": "npm",
    "_loc": "C:\\Users\\emilf\\OneDrive\\Skrivebord\\qb\\qb\\cache\\yarn-cache\\v6\\npm-zod-3.11.6-e43a5e0c213ae2e02aefe7cb2b1a6fa3d7f1f483-integrity\\node_modules\\zod\\package.json",
    "readmeFilename": "README.md",
    "readme": "<p align=\"center\">\n  <img src=\"logo.svg\" width=\"200px\" align=\"center\" />\n  <h1 align=\"center\">Zod</h1>\n</p>\n<p align=\"center\">\n<a href=\"https://twitter.com/colinhacks\" rel=\"nofollow\"><img src=\"https://img.shields.io/badge/created%20by-@colinhacks-4BBAAB.svg\" alt=\"Created by Colin McDonnell\"></a>\n<a href=\"https://opensource.org/licenses/MIT\" rel=\"nofollow\"><img src=\"https://img.shields.io/github/license/colinhacks/zod\" alt=\"License\"></a>\n<a href=\"https://www.npmjs.com/package/zod\" rel=\"nofollow\"><img src=\"https://img.shields.io/npm/dw/zod.svg\" alt=\"npm\"></a>\n<a href=\"https://www.npmjs.com/package/zod\" rel=\"nofollow\"><img src=\"https://img.shields.io/github/stars/colinhacks/zod\" alt=\"stars\"></a>\n<a href=\"./src/__tests__\" rel=\"nofollow\"><img src=\"./coverage.svg\" alt=\"coverage\"></a>\n\n</p>\n<p align=\"center\">\nby [@colinhacks](https://twitter.com/colinhacks)\n</p>\n\n> Hi! Colin here, creator of Zod. I hope you find it easy to use and powerful enough for all your use cases. If you have any issues or suggestions, please  [open an issue](https://github.com/colinhacks/zod/issues/new)! \n>\n> If you like typesafety, check out my other library [tRPC](https://trpc.io). It works in concert with Zod to provide a seamless way to build end-to-end typesafe APIs without GraphQL or code generation ‚Äî just TypeScript.\n>\n> Colin (AKA [@colinhacks](https://twitter.com/colinhacks))\n\n<br/>\n\nThis docs have been translated into [Chinese](./README_ZH.md).\n\n# Table of contents\n\n- [What is Zod](#what-is-zod)\n- [Installation](#installation)\n- [Ecosystem](#ecosystem)\n- [Basic usage](#basic-usage)\n- [Defining schemas](#defining-schemas)\n  - [Primitives](#primitives)\n  - [Literals](#literals)\n  - [Strings](#strings)\n  - [Numbers](#numbers)\n  - [Booleans](#booleans)\n  - [Enums](#enums)\n    - [Zod enums](#zod-enums)\n    - [Native enums](#native-enums)\n  - [Optionals](#optionals)\n  - [Nullables](#nullables)\n  - [Objects](#objects)\n    - [.shape](#shape)\n    - [.extend](#extend)\n    - [.merge](#merge)\n    - [.pick/.omit](#pickomit)\n    - [.partial](#partial)\n    - [.deepPartial](#deepPartial)\n    - [.passthrough](#passthrough)\n    - [.strict](#strict)\n    - [.strip](#strip)\n    - [.catchall](#catchall)\n  - [Arrays](#arrays)\n    - [.nonempty](#nonempty)\n    - [.min/.max/.length](#minmaxlength)\n  - [Tuples](#tuples)\n  - [Records](#records)\n  - [Maps](#maps)\n  - [Sets](#sets)\n  - [Unions](#unions)\n  - [Recursive types](#recursive-types)\n    - [JSON type](#json-type)\n    - [Cyclical data](#cyclical-objects)\n  - [Promises](#promises)\n  - [Instanceof](#instanceof)\n  - [Function schemas](#function-schemas)\n  - [Preprocess](#preprocess)\n- [Schema methods](#zodtype-methods-and-properties)\n  - [.parse](#parse)\n  - [.parseAsync](#parseasync)\n  - [.safeParse](#safeparse)\n  - [.safeParseAsync](#safeparseasync)\n  - [.refine](#refine)\n  - [.superRefine](#superRefine)\n  - [.transform](#transform)\n  - [.default](#default)\n  - [.optional](#optional)\n  - [.nullable](#nullable)\n  - [.nullish](#nullish)\n  - [.array](#array)\n  - [.promise](#promise)\n  - [.or](#or)\n  - [.and](#and)\n- [Type inference](#type-inference)\n- [Errors](#errors)\n- [Comparison](#comparison)\n  - [Joi](#joi)\n  - [Yup](#yup)\n  - [io-ts](#io-ts)\n  - [Runtypes](#runtypes)\n- [Changelog](#changelog)\n\n<!-- **Zod 2 is coming! Follow [@colinhacks](https://twitter.com/colinhacks) to stay updated and discuss the future of Zod.** -->\n\n# What is Zod\n\nZod is a TypeScript-first schema declaration and validation library. I'm using the term \"schema\" to broadly refer to any data type, from a simple `string` to a complex nested object.\n\nZod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator _once_ and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures.\n\nSome other great aspects:\n\n- Zero dependencies\n- Works in Node.js and browsers (including IE 11)\n- Tiny: 8kb minified + zipped\n- Immutable: methods (i.e. `.optional()` return a new instance\n- Concise, chainable interface\n- Functional approach: [parse, don't validate](https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/)\n- Works with plain JavaScript too! You don't need to use TypeScript.\n\n# Sponsorship\n\nSponsorship at any level is appreciated and encouraged. Zod is maintained by a solo developer ([hi!](https://twitter.com/colinhacks)). For individual developers, consider the [Cup of Coffee tier](https://github.com/sponsors/colinhacks). If you built a paid product using Zod, consider the [Startup tier](https://github.com/sponsors/colinhacks). You can learn more about the tiers at [github.com/sponsors/colinhacks](https://github.com/sponsors/colinhacks).\n\n### Sponsors\n\n<table>\n  <tr>\n   <td align=\"center\">\n      <a href=\"https://deletype.com/\">\n        <img src=\"https://avatars0.githubusercontent.com/u/15068039?s=200&v=4\" width=\"100px;\" alt=\"\" />\n      </a>\n      <br>\n      <b>Deletype</b>\n      <br>\n      <a href=\"https://deletype.com/\">deletype.com/</a>\n    </td>\n  <td align=\"center\">\n      <a href=\"https://github.com/kevinsimper\">\n        <img src=\"https://avatars1.githubusercontent.com/u/1126497?s=460&v=4\" width=\"100px;\" alt=\"\" />\n      </a>\n      <br>\n      <b>Kevin Simper</b>\n      <br>\n      <a href=\"https://github.com/kevinsimper\">@kevinsimper</a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://twitter.com/flybayer\">\n        <img src=\"https://avatars2.githubusercontent.com/u/8813276?s=460&u=4ff8beb9a67b173015c4b426a92d89cab960af1b&v=4\" width=\"100px;\" alt=\"\"/>\n      </a>\n      <br>\n      <b>Brandon Bayer</b>\n      <br/>\n      <a href=\"https://twitter.com/flybayer\">@flybayer</a>,\n      <span>creator of <a href=\"https://blitzjs.com\">Blitz.js</a></span>\n      <br />\n    </td>\n    \n  </tr>\n  <tr>\n    <td align=\"center\">\n      <a href=\"https://www.bamboocreative.nz/\">\n        <img src=\"https://avatars1.githubusercontent.com/u/41406870?s=460&v=4\" width=\"100px;\" alt=\"\" />\n      </a>\n      <br>\n      <b>Bamboo Creative</b>\n      <br>\n      <a href=\"https://www.bamboocreative.nz/\">bamboocreative.nz</a>\n    </td>\n    <td align=\"center\">\n      <a href=\"https://github.com/jeremyBanks\">\n        <img src=\"https://avatars.githubusercontent.com/u/18020?s=400&u=dba6c1402ae1746a276a5d256e01d68e774a0e9d&v=4\" width=\"100px;\" alt=\"\" />\n      </a>\n      <br>\n      <b>Jeremy Banks</b>\n      <br>\n      <a href=\"https://github.com/jeremyBanks\">github.com/jeremyBanks</a>\n    </td>\n     <td align=\"center\">\n      <a href=\"https://marcatopartners.com/\">\n        <img src=\"https://avatars.githubusercontent.com/u/84106192?s=200&v=4\" width=\"100px;\" alt=\"Marcato Partners\" />\n      </a>\n      <br>\n      <b>Marcato Partners</b>\n      <br>\n      <a href=\"https://marcatopartners.com/\">marcatopartners.com</a>\n    </td>\n  </tr>\n</table>\n\n_To get your name + Twitter + website here, sponsor Zod at the [Freelancer](https://github.com/sponsors/colinhacks) or [Consultancy](https://github.com/sponsors/colinhacks) tier._\n\n# Installation\n\nTo install Zod v3:\n\n```sh\nnpm install zod\n```\n\n‚ö†Ô∏è IMPORTANT: You must enable `strict` mode in your `tsconfig.json`. This is a best practice for all TypeScript projects.\n\n```ts\n// tsconfig.json\n{\n  // ...\n  \"compilerOptions\": {\n    // ...\n    \"strict\": true\n  }\n}\n```\n\n#### TypeScript requirements\n\n- Zod 3.x requires TypeScript 4.1+\n- Zod 2.x requires TypeScript 3.7+\n- Zod 1.x requires TypeScript 3.3+\n\n# Ecosystem\n\nThere are a growing number of tools that are built atop or support Zod natively! If you've built a tool or library on top of Zod, tell me about it [on Twitter](https://twitter.com/colinhacks) or [start a Discussion](https://github.com/colinhacks/zod/discussions). I'll add it below and tweet it out.\n\n- [`tRPC`](https://github.com/trpc/trpc): Build end-to-end typesafe APIs without GraphQL.\n- [`ts-to-zod`](https://github.com/fabien0102/ts-to-zod): Convert TypeScript definitions into Zod schemas.\n- [`@anatine/zod-openapi`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-openapi): Converts a Zod schema to an OpenAPI v3.x `SchemaObject`.\n- [`@anatine/zod-mock`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-mock): Generate mock data from a Zod schema. Powered by [faker.js](https://github.com/Marak/Faker.js).\n- [`@anatine/zod-nestjs`](https://github.com/anatine/zod-plugins/tree/main/libs/zod-nestjs): Helper methods for using Zod in a NestJS project.\n- [`zod-mocking`](https://github.com/dipasqualew/zod-mocking): Generate mock data from your Zod schemas.\n- [`zod-fast-check`](https://github.com/DavidTimms/zod-fast-check): Generate `fast-check` arbitraries from Zod schemas.\n- [`zod-endpoints`](https://github.com/flock-community/zod-endpoints): Contract-first strictly typed endpoints with Zod. OpenAPI compatible.\n- [`express-zod-api`](https://github.com/RobinTail/express-zod-api): Build Express-based APIs with I/O schema validation and custom middlewares.\n- [`zod-to-json-schema`](https://github.com/StefanTerdell/zod-to-json-schema): Convert your Zod schemas into [JSON Schemas](https://json-schema.org/).\n- [`json-to-zod`](https://github.com/rsinohara/json-to-zod): Convert JSON objects into Zod schemas. Use it live [here](https://rsinohara.github.io/json-to-zod-react/).\n- [`zod-dto`](https://github.com/kbkk/abitia/tree/master/packages/zod-dto): Generate Nest.js DTOs from a Zod schema.\n\n### Form integrations\n\n- [`react-hook-form`](https://github.com/react-hook-form/resolvers#zod): A first-party Zod resolver for React Hook Form\n- [`formik`](https://github.com/robertLichtnow/zod-formik-adapter): A community-maintained Formik adapter for Zod\n\n# Basic usage\n\nCreating a simple string schema\n\n```ts\nimport { z } from \"zod\";\n\n// creating a schema for strings\nconst mySchema = z.string();\n\n// parsing\nmySchema.parse(\"tuna\"); // => \"tuna\"\nmySchema.parse(12); // => throws ZodError\n\n// \"safe\" parsing (doesn't throw error if validation fails)\nmySchema.safeParse(\"tuna\"); // => { success: true; data: \"tuna\" }\nmySchema.safeParse(12); // => { success: false; error: ZodError }\n```\n\nCreating an object schema\n\n```ts\nimport { z } from \"zod\";\n\nconst User = z.object({\n  username: z.string(),\n});\n\nUser.parse({ username: \"Ludwig\" });\n\n// extract the inferred type\ntype User = z.infer<typeof User>;\n// { username: string }\n```\n\n# Defining schemas\n\n## Primitives\n\n```ts\nimport { z } from \"zod\";\n\n// primitive values\nz.string();\nz.number();\nz.bigint();\nz.boolean();\nz.date();\n\n// empty types\nz.undefined();\nz.null();\nz.void(); // accepts undefined\n\n// catch-all types\n// allows any value\nz.any();\nz.unknown();\n\n// never type\n// allows no values\nz.never();\n```\n\n## Literals\n\n```ts\nconst tuna = z.literal(\"tuna\");\nconst twelve = z.literal(12);\nconst tru = z.literal(true);\n\n// retrieve literal value\ntuna.value; // \"tuna\"\n```\n\n> Currently there is no support for Date or bigint literals in Zod. If you have a use case for this feature, please file an issue.\n\n## Strings\n\nYou can customize certain errors when creating a string schema.\n\n```ts\nconst name = z.string({\n  required: \"Name is required\",\n  invalid: \"Invalid name\",\n});\n```\n\nZod includes a handful of string-specific validations.\n\n```ts\nz.string().max(5);\nz.string().min(5);\nz.string().length(5);\nz.string().email();\nz.string().url();\nz.string().uuid();\nz.string().cuid();\nz.string().regex(regex);\n\n// deprecated, equivalent to .min(1)\nz.string().nonempty();\n\n// optional custom error message\nz.string().nonempty({ message: \"Can't be empty\" });\n```\n\n> Check out [validator.js](https://github.com/validatorjs/validator.js) for a bunch of other useful string validation functions.\n\n#### Custom error messages\n\nYou can customize certain errors when creating a string schema.\n\n```ts\nconst name = z.string({\n  required_error: \"Name is required\",\n  invalid_type_error: \"Name must be a string\",\n});\n```\n\nWhen using validation methods, you can pass in an additional argument to provide a custom error message.\n\n```ts\nz.string().min(5, { message: \"Must be 5 or more characters long\" });\nz.string().max(5, { message: \"Must be 5 or fewer characters long\" });\nz.string().length(5, { message: \"Must be exactly 5 characters long\" });\nz.string().email({ message: \"Invalid email address\" });\nz.string().url({ message: \"Invalid url\" });\nz.string().uuid({ message: \"Invalid UUID\" });\n```\n\n## Numbers\n\nYou can customize certain error messages when creating a number schema.\n\n```ts\nconst age = z.number({\n  required_error: \"Age is required\",\n  invalid_type_error: \"Age must be a number\",\n});\n```\n\nZod includes a handful of number-specific validations.\n\n```ts\nz.number().gt(5);\nz.number().gte(5); // alias .min(5)\nz.number().lt(5);\nz.number().lte(5); // alias .max(5)\n\nz.number().int(); // value must be an integer\n\nz.number().positive(); //     > 0\nz.number().nonnegative(); //  >= 0\nz.number().negative(); //     < 0\nz.number().nonpositive(); //  <= 0\n\nz.number().multipleOf(5); // Evenly divisible by 5. Alias .step(5)\n```\n\nOptionally, you can pass in a second argument to provide a custom error message.\n\n```ts\nz.number().lte(5, { message: \"thisüëèisüëètooüëèbig\" });\n```\n\n## Booleans\n\nYou can customize certain error messages when creating a boolean schema.\n\n```ts\nconst isActive = z.boolean({\n  required_error: \"isActive is required\",\n  invalid_type_error: \"isActive must be a boolean\",\n});\n```\n\n## Enums\n\nThere are two ways to define enums in Zod.\n\n### Zod enums\n\n```ts\nconst FishEnum = z.enum([\"Salmon\", \"Tuna\", \"Trout\"]);\ntype FishEnum = z.infer<typeof FishEnum>;\n// 'Salmon' | 'Tuna' | 'Trout'\n```\n\nYou must pass the array of values directly into `z.enum()`. Alternatively, use `as const` to define your enum values as a tuple of strings. See the [const assertion docs](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions) for details.\n\n```ts\nconst VALUES = [\"Salmon\", \"Tuna\", \"Trout\"] as const;\nconst FishEnum = z.enum(VALUES);\n```\n\nThis is not allowed:\n\n```ts\nconst fish = [\"Salmon\", \"Tuna\", \"Trout\"];\nconst FishEnum = z.enum(fish);\n```\n\nIn that case, the inferred type of `fish` is simply `string[]`, so Zod isn't able to infer the individual enum elements.\n\n**Autocompletion**\n\nTo get autocompletion with a Zod enum, use the `.enum` property of your schema:\n\n```ts\nFishEnum.enum.Salmon; // => autocompletes\n\nFishEnum.enum;\n/* \n=> {\n  Salmon: \"Salmon\",\n  Tuna: \"Tuna\",\n  Trout: \"Trout\",\n} \n*/\n```\n\nYou can also retrieve the list of options as a tuple with the `.options` property:\n\n```ts\nFishEnum.options; // [\"Salmon\", \"Tuna\", \"Trout\"]);\n```\n\n### Native enums\n\nZod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-party library (or you don't want to rewrite your existing enums) you can use `z.nativeEnum()` .\n\n**Numeric enums**\n\n```ts\nenum Fruits {\n  Apple,\n  Banana,\n}\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // Fruits\n\nFruitEnum.parse(Fruits.Apple); // passes\nFruitEnum.parse(Fruits.Banana); // passes\nFruitEnum.parse(0); // passes\nFruitEnum.parse(1); // passes\nFruitEnum.parse(3); // fails\n```\n\n**String enums**\n\n```ts\nenum Fruits {\n  Apple = \"apple\",\n  Banana = \"banana\",\n  Cantaloupe, // you can mix numerical and string enums\n}\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // Fruits\n\nFruitEnum.parse(Fruits.Apple); // passes\nFruitEnum.parse(Fruits.Cantaloupe); // passes\nFruitEnum.parse(\"apple\"); // passes\nFruitEnum.parse(\"banana\"); // passes\nFruitEnum.parse(0); // passes\nFruitEnum.parse(\"Cantaloupe\"); // fails\n```\n\n**Const enums**\n\nThe `.nativeEnum()` function works for `as const` objects as well. ‚ö†Ô∏è `as const` required TypeScript 3.4+!\n\n```ts\nconst Fruits = {\n  Apple: \"apple\",\n  Banana: \"banana\",\n  Cantaloupe: 3,\n} as const;\n\nconst FruitEnum = z.nativeEnum(Fruits);\ntype FruitEnum = z.infer<typeof FruitEnum>; // \"apple\" | \"banana\" | 3\n\nFruitEnum.parse(\"apple\"); // passes\nFruitEnum.parse(\"banana\"); // passes\nFruitEnum.parse(3); // passes\nFruitEnum.parse(\"Cantaloupe\"); // fails\n```\n\n## Optionals\n\nYou can make any schema optional with `z.optional()`:\n\n```ts\nconst schema = z.optional(z.string());\n\nschema.parse(undefined); // => returns undefined\ntype A = z.infer<typeof schema>; // string | undefined\n```\n\nYou can make an existing schema optional with the `.optional()` method:\n\n```ts\nconst user = z.object({\n  username: z.string().optional(),\n});\ntype C = z.infer<typeof user>; // { username?: string | undefined };\n```\n\n#### `.unwrap`\n\n```ts\nconst stringSchema = z.string();\nconst optionalString = stringSchema.optional();\noptionalString.unwrap() === stringSchema; // true\n```\n\n## Nullables\n\nSimilarly, you can create nullable types like so:\n\n```ts\nconst nullableString = z.nullable(z.string());\nnullableString.parse(\"asdf\"); // => \"asdf\"\nnullableString.parse(null); // => null\n```\n\nYou can make an existing schema nullable with the `nullable` method:\n\n```ts\nconst E = z.string().nullable(); // equivalent to D\ntype E = z.infer<typeof E>; // string | null\n```\n\n#### `.unwrap`\n\n```ts\nconst stringSchema = z.string();\nconst nullableString = stringSchema.nullable();\nnullableString.unwrap() === stringSchema; // true\n```\n\n## Objects\n\n```ts\n// all properties are required by default\nconst Dog = z.object({\n  name: z.string(),\n  age: z.number(),\n});\n\n// extract the inferred type like this\ntype Dog = z.infer<typeof Dog>;\n\n// equivalent to:\ntype Dog = {\n  name: string;\n  age: number;\n};\n```\n\n### `.shape`\n\nUse `.shape` to access the schemas for a particular key.\n\n```ts\nDog.shape.name; // => string schema\nDog.shape.age; // => number schema\n```\n\n### `.extend`\n\nYou can add additional fields an object schema with the `.extend` method.\n\n```ts\nconst DogWithBreed = Dog.extend({\n  breed: z.string(),\n});\n```\n\nYou can use `.extend` to overwrite fields! Be careful with this power!\n\n### `.merge`\n\nEquivalent to `A.extend(B.shape)`.\n\n```ts\nconst BaseTeacher = z.object({ students: z.array(z.string()) });\nconst HasID = z.object({ id: z.string() });\n\nconst Teacher = BaseTeacher.merge(HasID);\ntype Teacher = z.infer<typeof Teacher>; // => { students: string[], id: string }\n```\n\n> If the two schemas share keys, the properties of B overrides the property of A. The returned schema also inherits the \"unknownKeys\" policy (strip/strict/passthrough) and the catchall schema of B.\n\n### `.pick/.omit`\n\nInspired by TypeScript's built-in `Pick` and `Omit` utility types, all Zod object schemas have `.pick` and `.omit` methods that return a modified version. Consider this Recipe schema:\n\n```ts\nconst Recipe = z.object({\n  id: z.string(),\n  name: z.string(),\n  ingredients: z.array(z.string()),\n});\n```\n\nTo only keep certain keys, use `.pick` .\n\n```ts\nconst JustTheName = Recipe.pick({ name: true });\ntype JustTheName = z.infer<typeof JustTheName>;\n// => { name: string }\n```\n\nTo remove certain keys, use `.omit` .\n\n```ts\nconst NoIDRecipe = Recipe.omit({ id: true });\n\ntype NoIDRecipe = z.infer<typeof NoIDRecipe>;\n// => { name: string, ingredients: string[] }\n```\n\n### `.partial`\n\nInspired by the built-in TypeScript utility type [Partial](https://www.typescriptlang.org/docs/handbook/utility-types.html#partialt), the `.partial` method makes all properties optional.\n\nStarting from this object:\n\n```ts\nconst user = z.object({\n  email: z.string()\n  username: z.string(),\n});\n// { email: string; username: string }\n```\n\nWe can create a partial version:\n\n```ts\nconst partialUser = user.partial();\n// { email?: string | undefined; username?: string | undefined }\n```\n\nYou can also specify which properties to make optional:\n\n```ts\nconst optionalEmail = user.partial({\n  email: true,\n});\n/* \n{ \n  email?: string | undefined; \n  username: string\n} \n*/\n```\n\n### `.deepPartial`\n\nThe `.partial` method is shallow ‚Äî it only applies one level deep. There is also a \"deep\" version:\n\n```ts\nconst user = z.object({\n  username: z.string(),\n  location: z.object({\n    latitude: z.number(),\n    longitude: z.number(),\n  }),\n  strings: z.array(z.object({ value: z.string() })),\n});\n\nconst deepPartialUser = user.deepPartial();\n\n/* \n{\n  username?: string | undefined, \n  location?: {\n    latitude?: number | undefined;\n    longitude?: number | undefined;\n  } | undefined,\n  strings?: { value?: string}[]\n}\n*/\n```\n\n> Important limitation: deep partials only work as expected in hierarchies of objects, arrays, and tuples.\n\n#### Unrecognized keys\n\nBy default Zod objects schemas strip out unrecognized keys during parsing.\n\n```ts\nconst person = z.object({\n  name: z.string(),\n});\n\nperson.parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => { name: \"bob dylan\" }\n// extraKey has been stripped\n```\n\n### `.passthrough`\n\nInstead, if you want to pass through unknown keys, use `.passthrough()` .\n\n```ts\nperson.passthrough().parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => { name: \"bob dylan\", extraKey: 61 }\n```\n\n### `.strict`\n\nYou can _disallow_ unknown keys with `.strict()` . If there are any unknown keys in the input, Zod will throw an error.\n\n```ts\nconst person = z\n  .object({\n    name: z.string(),\n  })\n  .strict();\n\nperson.parse({\n  name: \"bob dylan\",\n  extraKey: 61,\n});\n// => throws ZodError\n```\n\n### `.strip`\n\nYou can use the `.strip` method to reset an object schema to the default behavior (stripping unrecognized keys).\n\n### `.catchall`\n\nYou can pass a \"catchall\" schema into an object schema. All unknown keys will be validated against it.\n\n```ts\nconst person = z\n  .object({\n    name: z.string(),\n  })\n  .catchall(z.number());\n\nperson.parse({\n  name: \"bob dylan\",\n  validExtraKey: 61, // works fine\n});\n\nperson.parse({\n  name: \"bob dylan\",\n  validExtraKey: false, // fails\n});\n// => throws ZodError\n```\n\nUsing `.catchall()` obviates `.passthrough()` , `.strip()` , or `.strict()`. All keys are now considered \"known\".\n\n## Arrays\n\n```ts\nconst stringArray = z.array(z.string());\n\n// equivalent\nconst stringArray = z.string().array();\n```\n\nBe careful with the `.array()` method. It returns a new `ZodArray` instance. This means the _order_ in which you call methods matters. For instance:\n\n```ts\nz.string().optional().array(); // (string | undefined)[]\nz.string().array().optional(); // string[] | undefined\n```\n\n### `.nonempty`\n\nIf you want to ensure that an array contains at least one element, use `.nonempty()`.\n\n```ts\nconst nonEmptyStrings = z.string().array().nonempty();\n// the inferred type is now\n// [string, ...string[]]\n\nnonEmptyStrings.parse([]); // throws: \"Array cannot be empty\"\nnonEmptyStrings.parse([\"Ariana Grande\"]); // passes\n```\n\nYou can optionally specify a custom error message:\n\n```ts\n// optional custom error message\nconst nonEmptyStrings = z.string().array().nonempty({\n  message: \"Can't be empty!\",\n});\n```\n\n### `.min/.max/.length`\n\n```ts\nz.string().array().min(5); // must contain 5 or more items\nz.string().array().max(5); // must contain 5 or fewer items\nz.string().array().length(5); // must contain 5 items exactly\n```\n\nUnlike `.nonempty()` these methods do not change the inferred type.\n\n## Tuples\n\nUnlike arrays, tuples have a fixed number of elements and each element can have a different type.\n\n```ts\nconst athleteSchema = z.tuple([\n  z.string(), // name\n  z.number(), // jersey number\n  z.object({\n    pointsScored: z.number(),\n  }), // statistics\n]);\n\ntype Athlete = z.infer<typeof athleteSchema>;\n// type Athlete = [string, number, { pointsScored: number }]\n```\n\n## Unions\n\nZod includes a built-in `z.union` method for composing \"OR\" types.\n\n```ts\nconst stringOrNumber = z.union([z.string(), z.number()]);\n\nstringOrNumber.parse(\"foo\"); // passes\nstringOrNumber.parse(14); // passes\n```\n\nZod will test the input against each of the \"options\" in order and return the first value that validates successfully.\n\nFor convenience, you can also use the `.or` method:\n\n```ts\nconst stringOrNumber = z.string().or(z.number());\n```\n\n## Records\n\nRecord schemas are used to validate types such as `{ [k: string]: number }`.\n\nIf you want to validate the _values_ of an object against some schema but don't care about the keys, use `Record`.\n\n```ts\nconst NumberCache = z.record(z.number());\n\ntype NumberCache = z.infer<typeof NumberCache>;\n// => { [k: string]: number }\n```\n\nThis is particularly useful for storing or caching items by ID.\n\n```ts\nconst userStore: UserStore = {};\n\nuserStore[\"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd\"] = {\n  name: \"Carlotta\",\n}; // passes\n\nuserStore[\"77d2586b-9e8e-4ecf-8b21-ea7e0530eadd\"] = {\n  whatever: \"Ice cream sundae\",\n}; // TypeError\n```\n\n#### A note on numerical keys\n\nYou may have expected `z.record()` to accept two arguments, one for the keys and one for the values. After all, TypeScript's built-in Record type does: `Record<KeyType, ValueType>` . Otherwise, how do you represent the TypeScript type `Record<number, any>` in Zod?\n\nAs it turns out, TypeScript's behavior surrounding `[k: number]` is a little unintuitive:\n\n```ts\nconst testMap: { [k: number]: string } = {\n  1: \"one\",\n};\n\nfor (const key in testMap) {\n  console.log(`${key}: ${typeof key}`);\n}\n// prints: `1: string`\n```\n\nAs you can see, JavaScript automatically casts all object keys to strings under the hood.\n\nSince Zod is trying to bridge the gap between static and runtime types, it doesn't make sense to provide a way of creating a record schema with numerical keys, since there's no such thing as a numerical key in runtime JavaScript.\n\n## Maps\n\n```ts\nconst stringNumberMap = z.map(z.string(), z.number());\n\ntype StringNumberMap = z.infer<typeof stringNumberMap>;\n// type StringNumber = Map<string, number>\n```\n\n## Sets\n\n```ts\nconst numberSet = z.set(z.string());\ntype numberSet = z.infer<typeof numberSet>;\n// Set<number>\n```\n\n## Intersections\n\n<!-- > ‚ö†Ô∏è Intersections are deprecated. If you are trying to merge objects, use the `.merge` method instead. -->\n\nIntersections are useful for creating \"logical AND\" types. This is useful for intersecting two object types.\n\n```ts\nconst Person = z.object({\n  name: z.string(),\n});\n\nconst Employee = z.object({\n  role: z.string(),\n});\n\nconst EmployedPerson = z.intersection(Person, Employee);\n\n// equivalent to:\nconst EmployedPerson = Person.and(Employee);\n```\n\nThough in many cases, it is recommended to use `A.merge(B)` to merge two objects. The `.merge` method returns a new `ZodObject` instance, whereas `A.and(B)` returns a less useful `ZodIntersection` instance that lacks common object methods like `pick` and `omit`.\n\n```ts\nconst a = z.union([z.number(), z.string()]);\nconst b = z.union([z.number(), z.boolean()]);\nconst c = z.intersection(a, b);\n\ntype c = z.infer<typeof c>; // => number\n```\n\n<!-- Intersections in Zod are not smart. Whatever data you pass into `.parse()` gets passed into the two intersected schemas. Because Zod object schemas don't allow any unknown keys by default, there are some unintuitive behavior surrounding intersections of object schemas. -->\n\n<!--\n\n``` ts\nconst A = z.object({\n  a: z.string(),\n});\n\nconst B = z.object({\n  b: z.string(),\n});\n\nconst AB = z.intersection(A, B);\n\ntype Teacher = z.infer<typeof Teacher>;\n// { id:string; name:string };\n```  -->\n\n## Recursive types\n\nYou can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a \"type hint\".\n\n```ts\ninterface Category {\n  name: string;\n  subcategories: Category[];\n}\n\n// cast to z.ZodSchema<Category>\nconst Category: z.ZodSchema<Category> = z.lazy(() =>\n  z.object({\n    name: z.string(),\n    subcategories: z.array(Category),\n  })\n);\n\nCategory.parse({\n  name: \"People\",\n  subcategories: [\n    {\n      name: \"Politicians\",\n      subcategories: [{ name: \"Presidents\", subcategories: [] }],\n    },\n  ],\n}); // passes\n```\n\nUnfortunately this code is a bit duplicative, since you're declaring the types twice: once in the interface and again in the Zod definition.\n\n<!-- If your schema has lots of primitive fields, there's a way of reducing the amount of duplication:\n\n```ts\n// define all the non-recursive stuff here\nconst BaseCategory = z.object({\n  name: z.string(),\n  tags: z.array(z.string()),\n  itemCount: z.number(),\n});\n\n// create an interface that extends the base schema\ninterface Category extends z.infer<typeof BaseCategory> {\n  subcategories: Category[];\n}\n\n// merge the base schema with\n// a new Zod schema containing relations\nconst Category: z.ZodSchema<Category> = BaseCategory.merge(\n  z.object({\n    subcategories: z.lazy(() => z.array(Category)),\n  })\n);\n``` -->\n\n#### JSON type\n\nIf you want to validate any JSON value, you can use the snippet below.\n\n```ts\ntype Literal = boolean | null | number | string;\ntype Json = Literal | { [key: string]: Json } | Json[];\nconst literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);\nconst jsonSchema: z.ZodSchema<Json> = z.lazy(() =>\n  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])\n);\n\njsonSchema.parse(data);\n```\n\nThanks to [ggoodman](https://github.com/ggoodman) for suggesting this.\n\n#### Cyclical objects\n\nDespite supporting recursive schemas, passing an cyclical data into Zod will cause an infinite loop.\n\n## Promises\n\n```ts\nconst numberPromise = z.promise(z.number());\n```\n\n\"Parsing\" works a little differently with promise schemas. Validation happens in two parts:\n\n1. Zod synchronously checks that the input is an instance of Promise (i.e. an object with `.then` and `.catch` methods.).\n2. Zod uses `.then` to attach an additional validation step onto the existing Promise. You'll have to use `.catch` on the returned Promise to handle validation failures.\n\n```ts\nnumberPromise.parse(\"tuna\");\n// ZodError: Non-Promise type: string\n\nnumberPromise.parse(Promise.resolve(\"tuna\"));\n// => Promise<number>\n\nconst test = async () => {\n  await numberPromise.parse(Promise.resolve(\"tuna\"));\n  // ZodError: Non-number type: string\n\n  await numberPromise.parse(Promise.resolve(3.14));\n  // => 3.14\n};\n```\n\n<!-- #### Non-native promise implementations\n\nWhen \"parsing\" a promise, Zod checks that the passed value is an object with `.then` and `.catch` methods ‚Äî that's it. So you should be able to pass non-native Promises (Bluebird, etc) into `z.promise(...).parse` with no trouble. One gotcha: the return type of the parse function will be a _native_ `Promise` , so if you have downstream logic that uses non-standard Promise methods, this won't work. -->\n\n## Instanceof\n\nYou can use `z.instanceof` to check that the input is an instance of a class. This is useful to validate inputs against classes that are exported from third-party libraries.\n\n```ts\nclass Test {\n  name: string;\n}\n\nconst TestSchema = z.instanceof(Test);\n\nconst blob: any = \"whatever\";\nTestSchema.parse(new Test()); // passes\nTestSchema.parse(\"blob\"); // throws\n```\n\n## Function schemas\n\nZod also lets you define \"function schemas\". This makes it easy to validate the inputs and outputs of a function without intermixing your validation code and \"business logic\".\n\nYou can create a function schema with `z.function(args, returnType)` .\n\n```ts\nconst myFunction = z.function();\n\ntype myFunction = z.infer<typeof myFunction>;\n// => ()=>unknown\n```\n\n**Define inputs and output**\n\n```ts\nconst myFunction = z\n  .function()\n  .args(z.string(), z.number()) // accepts an arbitrary number of arguments\n  .returns(z.boolean());\ntype myFunction = z.infer<typeof myFunction>;\n// => (arg0: string, arg1: number)=>boolean\n```\n\n**Extract the input and output schemas**\nYou can extract the parameters and return type of a function schema.\n\n```ts\nmyFunction.parameters();\n// => ZodTuple<[ZodString, ZodNumber]>\n\nmyFunction.returnType();\n// => ZodBoolean\n```\n\n<!-- `z.function()` accepts two arguments:\n\n* `args: ZodTuple` The first argument is a tuple (created with `z.tuple([...])` and defines the schema of the arguments to your function. If the function doesn't accept arguments, you can pass an empty tuple (`z.tuple([])`).\n* `returnType: any Zod schema` The second argument is the function's return type. This can be any Zod schema. -->\n\n> You can use the special `z.void()` option if your function doesn't return anything. This will let Zod properly infer the type of void-returning functions. (Void-returning functions actually return undefined.)\n\n<!--\n\n``` ts\nconst args = z.tuple([z.string()]);\n\nconst returnType = z.number();\n\nconst myFunction = z.function(args, returnType);\ntype myFunction = z.infer<typeof myFunction>;\n// => (arg0: string)=>number\n``` -->\n\nFunction schemas have an `.implement()` method which accepts a function and returns a new function that automatically validates it's inputs and outputs.\n\n```ts\nconst trimmedLength = z\n  .function()\n  .args(z.string()) // accepts an arbitrary number of arguments\n  .returns(z.number())\n  .implement((x) => {\n    // TypeScript knows x is a string!\n    return x.trim().length;\n  });\n\ntrimmedLength(\"sandwich\"); // => 8\ntrimmedLength(\" asdf \"); // => 4\n```\n\nIf you only care about validating inputs, that's fine:\n\n```ts\nconst myFunction = z\n  .function()\n  .args(z.string())\n  .implement((arg) => {\n    return [arg.length]; //\n  });\nmyFunction; // (arg: string)=>number[]\n```\n\n## Preprocess\n\nTypically Zod operates under a \"parse then transform\" paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the [.transform docs](#transform).)\n\nBut sometimes you want to apply some transform to the input _before_ parsing happens. A common use case: type coercion. Zod enables this with the `z.preprocess()`.\n\n```ts\nconst castToString = z.preprocess((val) => String(val), z.string());\n```\n\nThis returns a `ZodEffects` instance. `ZodEffects` is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.\n\n# ZodType: methods and properties\n\nAll Zod schemas contain certain methods.\n\n### `.parse`\n\n`.parse(data:unknown): T`\n\nGiven any Zod schema, you can call its `.parse` method to check `data` is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.\n\n> IMPORTANT: In Zod 2 and Zod 1.11+, the value returned by `.parse` is a _deep clone_ of the variable you passed in. This was also the case in zod@1.4 and earlier.\n\n```ts\nconst stringSchema = z.string();\nstringSchema.parse(\"fish\"); // => returns \"fish\"\nstringSchema.parse(12); // throws Error('Non-string type: number');\n```\n\n### `.parseAsync`\n\n`.parseAsync(data:unknown): Promise<T>`\n\nIf you use asynchronous [refinements](#refine) or [transforms](#transform) (more on those later), you'll need to use `.parseAsync`\n\n```ts\nconst stringSchema = z.string().refine(async (val) => val.length > 20);\nconst value = await stringSchema.parseAsync(\"hello\"); // => hello\n```\n\n### `.safeParse`\n\n`.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }`\n\nIf you don't want Zod to throw errors when validation fails, use `.safeParse`. This method returns an object containing either the successfully parsed data or a ZodError instance containing detailed information about the validation problems.\n\n```ts\nstringSchema.safeParse(12);\n// => { success: false; error: ZodError }\n\nstringSchema.safeParse(\"billie\");\n// => { success: true; data: 'billie' }\n```\n\nThe result is a _discriminated union_ so you can handle errors very conveniently:\n\n```ts\nconst result = stringSchema.safeParse(\"billie\");\nif (!result.success) {\n  // handle error then return\n  result.error;\n} else {\n  // do something\n  result.data;\n}\n```\n\n### `.safeParseAsync`\n\n> Alias: `.spa`\n\nAn asynchronous version of `safeParse`.\n\n```ts\nawait stringSchema.safeParseAsync(\"billie\");\n```\n\nFor convenience, this has been aliased to `.spa`:\n\n```ts\nawait stringSchema.spa(\"billie\");\n```\n\n### `.refine`\n\n`.refine(validator: (data:T)=>any, params?: RefineParams)`\n\nZod lets you provide custom validation logic via _refinements_. (For advanced features like creating multiple issues and customizing error codes, see [`.superRefine`](#superrefine).)\n\nZod was designed to mirror TypeScript as closely as possible. But there are many so-called \"refinement types\" you may wish to check for that can't be represented in TypeScript's type system. For instance: checking that a number is an integer or that a string is a valid email address.\n\nFor example, you can define a custom validation check on _any_ Zod schema with `.refine` :\n\n```ts\nconst myString = z.string().refine((val) => val.length <= 255, {\n  message: \"String can't be more than 255 characters\",\n});\n```\n\n> ‚ö†Ô∏è Refinement functions should not throw. Instead they should return a falsy value to signal failure.\n\n#### Arguments\n\nAs you can see, `.refine` takes two arguments.\n\n1. The first is the validation function. This function takes one input (of type `T` ‚Äî the inferred type of the schema) and returns `any`. Any truthy value will pass validation. (Prior to zod@1.6.2 the validation function had to return a boolean.)\n2. The second argument accepts some options. You can use this to customize certain error-handling behavior:\n\n```ts\ntype RefineParams = {\n  // override error message\n  message?: string;\n\n  // appended to error path\n  path?: (string | number)[];\n\n  // params object you can use to customize message\n  // in error map\n  params?: object;\n};\n```\n\nFor advanced cases, the second argument can also be a function that returns `RefineParams`/\n\n```ts\nz.string().refine(\n  (val) => val.length > 10,\n  (val) => ({ message: `${val} is not more than 10 characters` })\n);\n```\n\n#### Customize error path\n\n```ts\nconst passwordForm = z\n  .object({\n    password: z.string(),\n    confirm: z.string(),\n  })\n  .refine((data) => data.password === data.confirm, {\n    message: \"Passwords don't match\",\n    path: [\"confirm\"], // path of error\n  })\n  .parse({ password: \"asdf\", confirm: \"qwer\" });\n```\n\nBecause you provided a `path` parameter, the resulting error will be:\n\n```ts\nZodError {\n  issues: [{\n    \"code\": \"custom\",\n    \"path\": [ \"confirm\" ],\n    \"message\": \"Passwords don't match\"\n  }]\n}\n```\n\n#### Asynchronous refinements\n\nRefinements can also be async:\n\n```ts\nconst userId = z.string().refine(async (id) => {\n  // verify that ID exists in database\n  return true;\n});\n```\n\n> ‚ö†Ô∏èIf you use async refinements, you must use the `.parseAsync` method to parse data! Otherwise Zod will throw an error.\n\n#### Relationship to transforms\n\nTransforms and refinements can be interleaved:\n\n```ts\nz.string()\n  .transform((val) => val.length)\n  .refine((val) => val > 25);\n```\n\n<!-- Note that the `path` is set to `[\"confirm\"]` , so you can easily display this error underneath the \"Confirm password\" textbox.\n\n\n```ts\nconst allForms = z.object({ passwordForm }).parse({\n  passwordForm: {\n    password: \"asdf\",\n    confirm: \"qwer\",\n  },\n});\n```\n\nwould result in\n\n```\n\nZodError {\n  issues: [{\n    \"code\": \"custom\",\n    \"path\": [ \"passwordForm\", \"confirm\" ],\n    \"message\": \"Passwords don't match\"\n  }]\n}\n``` -->\n\n### `.superRefine`\n\nThe `.refine` method is actually syntactic sugar atop a more versatile (and verbose) method called `superRefine`. Here's an example:\n\n```ts\nconst Strings = z.array(z.string()).superRefine((val, ctx) => {\n  if (val.length > 3) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.too_big,\n      maximum: 3,\n      type: \"array\",\n      inclusive: true,\n      message: \"Too many items üò°\",\n    });\n  }\n\n  if (val.length !== new Set(val).size) {\n    ctx.addIssue({\n      code: z.ZodIssueCode.custom,\n      message: `No duplicated allowed.`,\n    });\n  }\n});\n```\n\nYou can add as many issues as you like. If `ctx.addIssue` is NOT called during the execution of the function, validation passes.\n\nNormally refinements always create issues with a `ZodIssueCode.custom` error code, but with `superRefine` you can create any issue of any code. Each issue code is described in detail in the Error Handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md).\n\n#### Abort early\n\nBy default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to _abort early_ to prevent later refinements from being executed. To achieve this, pass the `fatal` flag to `ctx.addIssue`:\n\n```ts\nconst Strings = z\n  .number()\n  .superRefine((val, ctx) => {\n    if (val < 10) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: \"foo\",\n        fatal: true,\n      });\n    }\n  })\n  .superRefine((val, ctx) => {\n    if (val !== \" \") {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: \"bar\",\n      });\n    }\n  });\n```\n\n### `.transform`\n\nTo transform data after parsing, use the `transform` method.\n\n```ts\nconst stringToNumber = z.string().transform((val) => myString.length);\nstringToNumber.parse(\"string\"); // => 6\n```\n\n> ‚ö†Ô∏è Transform functions must not throw. Make sure to use refinements before the transform to make sure the input can be parsed by the transform.\n\n#### Chaining order\n\nNote that `stringToNumber` above is an instance of the `ZodEffects` subclass. It is NOT an instance of `ZodString`. If you want to use the built-in methods of `ZodString` (e.g. `.email()`) you must apply those methods _before_ any transforms.\n\n```ts\nconst emailToDomain = z\n  .string()\n  .email()\n  .transform((val) => val.split(\"@\")[1]);\n\nemailToDomain.parse(\"colinhacks@example.com\"); // => example.com\n```\n\n#### Relationship to refinements\n\nTransforms and refinements can be interleaved:\n\n```ts\nz.string()\n  .transform((val) => val.length)\n  .refine((val) => val > 25);\n```\n\n#### Async transforms\n\nTransforms can also be async.\n\n```ts\nconst IdToUser = z\n  .string()\n  .uuid()\n  .transform(async (id) => {\n    return await getUserById(id);\n  });\n```\n\n> ‚ö†Ô∏è If your schema contains asynchronous transforms, you must use .parseAsync() or .safeParseAsync() to parse data. Otherwise Zod will throw an error.\n\n### `.default`\n\nYou can use transforms to implement the concept of \"default values\" in Zod.\n\n```ts\nconst stringWithDefault = z.string().default(\"tuna\");\n\nstringWithDefault.parse(undefined); // => \"tuna\"\n```\n\nOptionally, you can pass a function into `.default` that will be re-executed whenever a default value needs to be generated:\n\n```ts\nconst numberWithRandomDefault = z.number().default(Math.random);\n\nnumberWithRandomDefault.parse(undefined); // => 0.4413456736055323\nnumberWithRandomDefault.parse(undefined); // => 0.1871840107401901\nnumberWithRandomDefault.parse(undefined); // => 0.7223408162401552\n```\n\n### `.optional`\n\nA convenience method that returns an optional version of a schema.\n\n```ts\nconst optionalString = z.string().optional(); // string | undefined\n\n// equivalent to\nz.optional(z.string());\n```\n\n### `.nullable`\n\nA convenience method that returns an nullable version of a schema.\n\n```ts\nconst nullableString = z.string().nullable(); // string | null\n\n// equivalent to\nz.nullable(z.string());\n```\n\n### `.nullish`\n\nA convenience method that returns a \"nullish\" version of a schema. Nullish schemas will accept both `undefined` and `null`. Read more about the concept of \"nullish\" [here](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing).\n\n```ts\nconst nullishString = z.string().nullish(); // string | null | undefined\n\n// equivalent to\nz.string().optional().nullable();\n```\n\n### `.array`\n\nA convenience method that returns an array schema for the given type:\n\n```ts\nconst nullableString = z.string().array(); // string[]\n\n// equivalent to\nz.array(z.string());\n```\n\n### `.promise`\n\nA convenience method for promise types:\n\n```ts\nconst stringPromise = z.string().promise(); // Promise<string>\n\n// equivalent to\nz.promise(z.string());\n```\n\n### `.or`\n\nA convenience method for union types.\n\n```ts\nz.string().or(z.number()); // string | number\n\n// equivalent to\nz.union([z.string(), z.number()]);\n```\n\n### `.and`\n\nA convenience method for creating intersection types.\n\n```ts\nz.object({ name: z.string() }).and(z.object({ age: z.number() })); // { name: string } & { age: number }\n\n// equivalent to\nz.intersection(z.string(), z.number());\n```\n\n# Type inference\n\nYou can extract the TypeScript type of any schema with `z.infer<typeof mySchema>` .\n\n```ts\nconst A = z.string();\ntype A = z.infer<typeof A>; // string\n\nconst u: A = 12; // TypeError\nconst u: A = \"asdf\"; // compiles\n```\n\n#### What about transforms?\n\nIn reality each Zod schema internally tracks **two** types: an input and an output. For most schemas (e.g. `z.string()`) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance `z.string().transform(val => val.length)` has an input of `string` and an output of `number`.\n\nYou can separately extract the input and output types like so:\n\n```ts\nconst stringToNumber = z.string().transform((val) => val.length);\n\n// ‚ö†Ô∏è Important: z.infer returns the OUTPUT type!\ntype input = z.input<typeof stringToNumber>; // string\ntype output = z.output<typeof stringToNumber>; // number\n\n// equivalent to z.output!\ntype inferred = z.infer<typeof stringToNumber>; // number\n```\n\n# Errors\n\nZod provides a subclass of Error called `ZodError`. ZodErrors contain an `issues` array containing detailed information about the validation problems.\n\n```ts\nconst data = z\n  .object({\n    name: z.string(),\n  })\n  .safeParse({ name: 12 });\n\nif (!data.success) {\n  data.error.issues;\n  /* [\n      {\n        \"code\": \"invalid_type\",\n        \"expected\": \"string\",\n        \"received\": \"number\",\n        \"path\": [ \"name\" ],\n        \"message\": \"Expected string, received number\"\n      }\n  ] */\n}\n```\n\n#### Error formatting\n\nYou can use the `.format()` method to convert this error into a nested object.\n\n```ts\ndata.error.format();\n/* {\n  name: { _errors: [ 'Expected string, received number' ] }\n} */\n```\n\nFor detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide: [ERROR_HANDLING.md](ERROR_HANDLING.md)\n\n# Comparison\n\nThere are a handful of other widely-used validation libraries, but all of them have certain design limitations that make for a non-ideal developer experience.\n\n<!-- The table below summarizes the feature differences. Below the table there are more involved discussions of certain alternatives, where necessary. -->\n\n<!-- | Feature                                                                                                                | [Zod](https://github.com/colinhacks) | [Joi](https://github.com/hapijs/joi) | [Yup](https://github.com/jquense/yup) | [io-ts](https://github.com/gcanti/io-ts) | [Runtypes](https://github.com/pelotom/runtypes) | [ow](https://github.com/sindresorhus/ow) | [class-validator](https://github.com/typestack/class-validator) |\n| ---------------------------------------------------------------------------------------------------------------------- | :-----------------------------: | :----------------------------------: | :-----------------------------------: | :--------------------------------------: | :---------------------------------------------: | :--------------------------------------: | :-------------------------------------------------------------: |\n| <abbr title='Any ability to extract a TypeScript type from a validator instance counts.'>Type inference</abbr>         |               üü¢                |                  üî¥                  |                  üü¢                   |                    üü¢                    |                       üü¢                        |                    üü¢                    |                               üü¢                                |\n| <abbr title=\"Yup's inferred types are incorrect in certain cases, see discussion below.\">Correct type inference</abbr> |               üü¢                |                  üî¥                  |                  üî¥                   |                    üü¢                    |                       üü¢                        |                    üü¢                    |                               üü¢                                |\n\n<abbr title=\"number, string, boolean, null, undefined\">Primitive Types</abbr>\n<abbr title=\"Includes any checks beyond 'Is this a string?', e.g. min/max length, isEmail, isURL, case checking, etc.\">String Validation</abbr>\n<abbr title=\"Includes any checks beyond 'Is this a number?', e.g. min/max, isPositive, integer vs float, etc.\">Number Validation</abbr>\nDates\n\nPrimitive Literals\nObject Literals\nTuple Literals\nObjects\nArrays\nNon-empty arrays\nUnions\nOptionals\nNullable\nEnums\nEnum Autocomplete\nIntersections\nObject Merging\nTuples\nRecursive Types\nFunction Schemas\n\n<abbr title=\"For instance, Yup allows custom error messages with the syntax yup.number().min(5, 'Number must be more than 5!')\">Validation Messages</abbr>\nImmutable instances\nType Guards\nValidity Checking\nCasting\nDefault Values\nRich Errors\nBranded -->\n\n<!-- - Missing object methods: (pick, omit, partial, deepPartial, merge, extend)\n\n* Missing nonempty arrays with proper typing (`[T, ...T[]]`)\n* Missing lazy/recursive types\n* Missing promise schemas\n* Missing function schemas\n* Missing union & intersection schemas\n* Missing support for parsing cyclical data (maybe)\n* Missing error customization -->\n\n#### Joi\n\n[https://github.com/hapijs/joi](https://github.com/hapijs/joi)\n\nDoesn't support static type inference üòï\n\n#### Yup\n\n[https://github.com/jquense/yup](https://github.com/jquense/yup)\n\nYup is a full-featured library that was implemented first in vanilla JS, and later rewritten in TypeScript.\n\nDifferences\n\n- Supports casting and transforms\n- All object fields are optional by default\n- Missing object methods: (partial, deepPartial)\n<!-- - Missing nonempty arrays with proper typing (`[T, ...T[]]`) -->\n- Missing promise schemas\n- Missing function schemas\n- Missing union & intersection schemas\n\n<!-- ¬πYup has a strange interpretation of the word `required`. Instead of meaning \"not undefined\", Yup uses it to mean \"not empty\". So `yup.string().required()` will not accept an empty string, and `yup.array(yup.string()).required()` will not accept an empty array. Instead, Yup us Zod arrays there is a dedicated `.nonempty()` method to indicate this, or you can implement it with a custom refinement. -->\n\n#### io-ts\n\n[https://github.com/gcanti/io-ts](https://github.com/gcanti/io-ts)\n\nio-ts is an excellent library by gcanti. The API of io-ts heavily inspired the design of Zod.\n\nIn our experience, io-ts prioritizes functional programming purity over developer experience in many cases. This is a valid and admirable design goal, but it makes io-ts particularly hard to integrate into an existing codebase with a more procedural or object-oriented bias. For instance, consider how to define an object with optional properties in io-ts:\n\n```ts\nimport * as t from \"io-ts\";\n\nconst A = t.type({\n  foo: t.string,\n});\n\nconst B = t.partial({\n  bar: t.number,\n});\n\nconst C = t.intersection([A, B]);\n\ntype C = t.TypeOf<typeof C>;\n// returns { foo: string; bar?: number | undefined }\n```\n\nYou must define the required and optional props in separate object validators, pass the optionals through `t.partial` (which marks all properties as optional), then combine them with `t.intersection` .\n\nConsider the equivalent in Zod:\n\n```ts\nconst C = z.object({\n  foo: z.string(),\n  bar: z.number().optional(),\n});\n\ntype C = z.infer<typeof C>;\n// returns { foo: string; bar?: number | undefined }\n```\n\nThis more declarative API makes schema definitions vastly more concise.\n\n`io-ts` also requires the use of gcanti's functional programming library `fp-ts` to parse results and handle errors. This is another fantastic resource for developers looking to keep their codebase strictly functional. But depending on `fp-ts` necessarily comes with a lot of intellectual overhead; a developer has to be familiar with functional programming concepts and the `fp-ts` nomenclature to use the library.\n\n- Supports codecs with serialization & deserialization transforms\n- Supports branded types\n- Supports advanced functional programming, higher-kinded types, `fp-ts` compatibility\n- Missing object methods: (pick, omit, partial, deepPartial, merge, extend)\n- Missing nonempty arrays with proper typing (`[T, ...T[]]`)\n- Missing promise schemas\n- Missing function schemas\n\n#### Runtypes\n\n[https://github.com/pelotom/runtypes](https://github.com/pelotom/runtypes)\n\nGood type inference support, but limited options for object type masking (no `.pick` , `.omit` , `.extend` , etc.). No support for `Record` s (their `Record` is equivalent to Zod's `object` ). They DO support branded and readonly types, which Zod does not.\n\n- Supports \"pattern matching\": computed properties that distribute over unions\n- Supports readonly types\n- Missing object methods: (deepPartial, merge)\n- Missing nonempty arrays with proper typing (`[T, ...T[]]`)\n- Missing promise schemas\n- Missing error customization\n\n#### Ow\n\n[https://github.com/sindresorhus/ow](https://github.com/sindresorhus/ow)\n\nOw is focused on function input validation. It's a library that makes it easy to express complicated assert statements, but it doesn't let you parse untyped data. They support a much wider variety of types; Zod has a nearly one-to-one mapping with TypeScript's type system, whereas ow lets you validate several highly-specific types out of the box (e.g. `int32Array` , see full list in their README).\n\nIf you want to validate function inputs, use function schemas in Zod! It's a much simpler approach that lets you reuse a function type declaration without repeating yourself (namely, copy-pasting a bunch of ow assertions at the beginning of every function). Also Zod lets you validate your return types as well, so you can be sure there won't be any unexpected data passed downstream.\n\n# Changelog\n\nView the changelog at [CHANGELOG.md](CHANGELOG.md)\n",
    "licenseText": "MIT License\n\nCopyright (c) 2020 Colin McDonnell\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/zod/-/zod-3.11.6.tgz#e43a5e0c213ae2e02aefe7cb2b1a6fa3d7f1f483",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/zod/-/zod-3.11.6.tgz",
    "hash": "e43a5e0c213ae2e02aefe7cb2b1a6fa3d7f1f483",
    "integrity": "sha512-daZ80A81I3/9lIydI44motWe6n59kRBfNzTuS2bfzVh1nAXi667TOTWWtatxyG+fwgNUiagSj/CWZwRRbevJIg==",
    "registry": "npm",
    "packageName": "zod",
    "cacheIntegrity": "sha512-daZ80A81I3/9lIydI44motWe6n59kRBfNzTuS2bfzVh1nAXi667TOTWWtatxyG+fwgNUiagSj/CWZwRRbevJIg== sha1-5DpeDCE64uAq7+fLKxpvo9fx9IM="
  },
  "registry": "npm",
  "hash": "e43a5e0c213ae2e02aefe7cb2b1a6fa3d7f1f483"
}